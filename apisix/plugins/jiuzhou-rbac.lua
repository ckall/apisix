---
--- Generated by Luanalysis
--- Created by kuncheng.
--- DateTime: 2024/1/24 11:19 AM
---
local core = require("apisix.core")
local jwt = require("resty.jwt")
local ngx = ngx
local http = require("resty.http")
local lrucache = core.lrucache.new({
    type = "plugin",
    count = 10000,
    ttl = 5 * 60,
})
local json = core.json
local auth_header_key = "X-JiuZhou-Authorization"
local auth_secret = "^chen|tian|zhen$"
local user_info_key1 = "X-JiuZhou-Auth-Info"
local user_info_key2 = "user"
local plugin_name = "jiuzhou-rbac"
local log = core.log
local version = "2.0.1"
local schema = {}
local metadata_schema = {}
local _M = {
    version = version,
    name = plugin_name,
    schema = schema,
    priority = 91,
    metadata_schema = metadata_schema,
}


local function send_auth(token, user_id, method, uri)
    local httpc = http.new()
    httpc:set_timeout(5 * 1000) -- 设置连接、发送、读取的总超时时间

    -- 连接到指定主机
    local ok, err = httpc:connect({
        scheme = "http",
        host = "open.duanju.com",
        port = 80,
    })
    if not ok then
        log.error("Failed to connect to host: ", err)
        return nil, err
    end

    -- 设置发送和读取超时
    httpc:set_timeouts(5000, 5000, 5000) -- connect_timeout, send_timeout, read_timeout

    -- 构造请求体
    local body = json.encode({
        user_id = user_id,
        method = method,
        path = uri,
    })

    log.info("Sending request with body: ", body)

    -- 发起 HTTP 请求
    local res
    res, err = httpc:request({
        method = "POST",
        path = "/v1/user/route/app",
        body = body,
        headers = {
            ["Content-Type"] = "application/json",
            ["X-JiuZhou-Authorization"] = token,
            ["X-JiuZhou-Service"] = "AuthSSO",
        }
    })
    if err then
        log.error("Failed to send data: ", err)
        httpc:close()
        return nil, err
    end
    -- 读取响应体
    local res_body, read_err = res:read_body()
    if read_err then
        log.error("Failed to read response body: ", read_err)
        httpc:close()
        return nil, read_err
    end
    -- 使用 keepalive 以便重用连接
    ok, err = httpc:set_keepalive(60000, 10)
    if not ok then
        log.error("Failed to set keepalive: ", err)
        httpc:close()
        return nil, err
    end

    return {
        status = res.status,
        body = res_body
    }, nil
end

--检查配置文件
function _M.check_schema(conf, schema_type)
    if schema_type == core.schema.TYPE_METADATA then
        return core.schema.check(metadata_schema, conf)
    end
    return core.schema.check(schema, conf)
end

local function verify_jwt(token)
    local jwt_obj = jwt:verify(auth_secret, token)
    if not jwt_obj["verified"] then
        return nil
    end
    return jwt_obj.payload
end
--处理请求
function _M.rewrite(conf, ctx)
    --解析jwt
    local auth_header = core.request.header(ctx, auth_header_key)
    -- 没有认证信息就直接过
    -- 这里算是漏洞，应该返回401,但是为了兼容上一个版本(上传文件), 所以只能先这样
    if not auth_header then
        return
    end
    local auth_data = core.lrucache.plugin_ctx(lrucache, ctx, nil, verify_jwt, auth_header)
    if not auth_data then
        return ngx.HTTP_UNAUTHORIZED, { msg = "token is invalid", code = "StatusUnauthorized", status = ngx.HTTP_UNAUTHORIZED }
    end
    local payload, err
    payload, err = json.encode(auth_data)
    if err then
        log.error("json encode error: ", err)
        return ngx.HTTP_INTERNAL_SERVER_ERROR, err
    end
    ctx.jwt = payload
    --添加请求头
    core.request.add_header(user_info_key1, payload)
    core.request.add_header(user_info_key2, payload)
    local method = core.request.get_method()
    local post_body2 = core.request.get_body(1024, ctx)
    if not post_body2 then
        post_body2 = ""
    end
    ctx.post_body = post_body2
    local uri = core.request.get_uri(ctx)
    local user_id = auth_data.user_id
    local httpc_res
    httpc_res, err = send_auth(auth_header, user_id, method, uri)
    if err then
        return ngx.HTTP_INTERNAL_SERVER_ERROR, err
    end
    if httpc_res.status ~= ngx.HTTP_OK then
        return httpc_res.status, httpc_res.body
    end
    return
end

function _M.header_filter(conf, ctx)
    core.response.add_header("Content-Type", "application/json")
    core.response.add_header("X-JiuZhou-Proxy", version)
    core.response.add_header("Developer", "ckallcloud@foxmail.com")
end

-- 记录日志
function _M.log(conf, ctx)
    local scheme = core.request.get_scheme(ctx)
    local method = core.request.get_method()
    local host = core.request.get_host(ctx)
    local uri = core.request.get_uri(ctx)
    local get_args = core.request.get_args(ctx)
    local url = string.format("%s://$s%s%s", scheme, host, uri, get_args)
    local jwt_auth = ctx.jwt
    local route_id = ctx.route_id
    if not jwt_auth then
        jwt_auth = "no auth jwt"
    end
    log.error(string.format(
        'jiuzhou plugins rbac log method: "%s" Host: "%s" Uri: "%s" post_body2: "%s" jwt_obj: "%s" route_id: %d',
        method, host, url, ctx.post_body, jwt_auth, route_id
    ))
    return
end

return _M
