---
--- Generated by Luanalysis
--- Created by kuncheng.
--- DateTime: 2024/1/24 11:19 AM
---
local core = require("apisix.core")
local jwt = require("resty.jwt")
--local mysql = require("resty.mysql")
local http = require("resty.http")
local json = core.json
local auth_header_key = "X-JiuZhou-Authorization"
local auth_secret = "^chen|tian|zhen$"
local user_info_key1 = "X-JiuZhou-Auth-Info"
local user_info_key2 = "user"
local plugin_name = "jiuzhou-rbac"
local log = core.log
local version = 2.0
local schema = {}
local metadata_schema = {}
local ngx = ngx
local _M = {
    version = version,
    name = plugin_name,
    schema = schema,
    priority = 91,
    metadata_schema = metadata_schema,
}

--检查配置文件
function _M.check_schema(conf, schema_type)
    if schema_type == core.schema.TYPE_METADATA then
        return core.schema.check(metadata_schema, conf)
    end

    return core.schema.check(schema, conf)
end


--处理请求
function _M.rewrite(conf, ctx)
    local auth_header =  core.request.header(ctx, auth_header_key)
     --解析jwt
    local jwt_obj = jwt:verify(auth_secret, auth_header)
    if not jwt_obj["verified"] then
        return 401, { message = "Missing authorization in request" }
    end
    core.response.add_header(user_info_key1, jwt_obj.payload)
    core.response.add_header(user_info_key2, jwt_obj.payload)
    local user_id = jwt_obj.payload.user_id
    local uri = ctx.var.uri
    local method =  core.request.get_method(ctx)
    local httpc = http.new()
    local request_body = json.encode({
        user_id = user_id,
        method = method,
        path = uri,
    })
    ngx.var.limit_rate = 1000
    --ngx.var.host
    local res, err = httpc:request_uri("http://172.16.179.166:8010/v1/user/route/app", {
        method = "POST",
        body = request_body,
        headers = {
            ["Content-Type"] = "application/json",
            [auth_header_key] = auth_header,
        }
    })
    if not res then
        log.error(ngx.ERR, "Failed to make request: ", err)
        return 500, {message= "request err1: " .. err, data = res, code = 500, request = request_body}
    end
    --if res.status ~= 200 then
    --    log.error(ngx.ERR, "Failed to make request: ", res.body)
    --    return 500, {message= "request err2: " .. res.body, data = res, code = 500, request = request_body}
    --end
    local body
    body, err = json.decode(res.body)
    if  body.status ~= 200 then
        return res.status, body
    end

    -- 创建http请求
    return
end

--处理请求
function _M.access(conf, ctx)
    log.info("rbac access:", json.encode(conf, true), " ctx:", json.encode(ctx, true))

    return
end

--处理请求
-- 处理header请求
function _M.header_filter(conf, ctx)
    core.response.add_header("Content-Type", "application/json")
    core.response.add_header("X-JiuZhou-Proxy", version)
end

local function my_timer_handler(premature, arg)
    if not premature then
        -- 在这里编写定时任务的具体逻辑
        log.error(ngx.INFO, "定时任务执行了，参数为: ", arg)
    end
end
-- 记录日志
function _M.log(conf, ctx)
    --获取url+path地址+query参数
    local scheme = core.request.get_scheme(ctx)
    local host = core.request.get_host(ctx)
    -- string 转 table
    local url = scheme .. "://" .. host .. ctx.var.uri .."?".. ctx.var.args
    log.error("jiuzhou rbac log URL:", "["..url.."]".." request:", core.request.get_body(1024, ctx))
    -- 定义定时任务的处理函数
    --
    --
    ---- 在请求处理阶段触发定时器，3秒后执行 my_timer_handler 函数
    --local ok, err = ngx.timer.at(3, my_timer_handler, "Hello, World!")
    --
    ---- 检查定时器是否成功创建
    --if not ok then
    --    log.error(ngx.ERR, "无法创建定时器：", err)
    --end
    --
    ---- 在这里编写处理请求的逻辑
    --ngx.say("Hello, from Nginx!")
    return
end

return _M


