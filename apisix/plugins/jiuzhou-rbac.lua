---
--- Generated by Luanalysis
--- Created by kuncheng.
--- DateTime: 2024/1/24 11:19 AM
---
local core = require("apisix.core")
local jwt = require("resty.jwt")
local ngx = ngx
local http = require("resty.http")
local redis_new = require("resty.redis").new

local lrucache = core.lrucache.new({
    type = "plugin",
    count = 10000,
    ttl = 5 * 60,
})
local json = core.json
local auth_header_key = "X-JiuZhou-Authorization"
local auth_secret = "^chen|tian|zhen$"
local user_info_key1 = "X-JiuZhou-Auth-Info"
local user_info_key2 = "user"
local plugin_name = "jiuzhou-rbac"
local log = core.log
local version = "2.0.1"
local schema = {}
local metadata_schema = {}
local _M = {
    version = version,
    name = plugin_name,
    schema = schema,
    priority = 91,
    metadata_schema = metadata_schema,
}

--redis_cli
--local red, err = redis_cli({
--    redis_host = "redis",
--    redis_database = 1,
--})
--if not red then
--    log.error("Failed to connect to redis: ", err)
--end
--local red_res1, err = red:set("test", "test")
--if err then
--    log.error("Failed to set value in redis1: ", err, red_res1)
--    return 500, err
--end
--local red_res, err = red:get("test")
--if err then
--    log.error("Failed to set value in redis2: ", err)
--    return 500, err
--end
--if red_res then
--    log.info("Successfully set value in redis2: ", red_res)
--    return
--end
local function redis_cli(conf)
    local red = redis_new()
    local timeout = conf.redis_timeout or 1000 -- 1sec

    red:set_timeouts(timeout, timeout, timeout)

    local sock_opts = {
        ssl = conf.redis_ssl,
        ssl_verify = conf.redis_ssl_verify
    }

    local ok, err = red:connect(conf.redis_host, conf.redis_port or 6379, sock_opts)
    if not ok then
        return false, err
    end

    local count
    count, err = red:get_reused_times()
    if 0 == count then
        if conf.redis_password and conf.redis_password ~= '' then
            local ok, err
            if conf.redis_username then
                ok, err = red:auth(conf.redis_username, conf.redis_password)
            else
                ok, err = red:auth(conf.redis_password)
            end
            if not ok then
                return nil, err
            end
        end

        -- select db
        if conf.redis_database ~= 0 then
            local ok, err = red:select(conf.redis_database)
            if not ok then
                return false, "failed to change redis db, err: " .. err
            end
        end
    elseif err then
        -- core.log.info(" err: ", err)
        return nil, err
    end
    return red, nil
end

local function send_auth(token, user_id, method, uri)
    local httpc = http.new()
    httpc:set_timeout(5 * 1000) -- 设置连接、发送、读取的总超时时间

    -- 连接到指定主机
    local ok, err = httpc:connect({
        scheme = "http",
        host = "open.duanju.com",
        port = 80,
    })
    if not ok then
        log.error("Failed to connect to host: ", err)
        return nil, err
    end

    -- 设置发送和读取超时
    httpc:set_timeouts(5000, 5000, 5000) -- connect_timeout, send_timeout, read_timeout

    -- 构造请求体
    local body = json.encode({
        user_id = user_id,
        method = method,
        path = uri,
    })

    log.info("Sending request with body: ", body)

    -- 发起 HTTP 请求
    local res
    res, err = httpc:request({
        method = "POST",
        path = "/v1/user/route/app",
        body = body,
        headers = {
            ["Content-Type"] = "application/json",
            ["X-JiuZhou-Authorization"] = token,
            ["X-JiuZhou-Service"] = "AuthSSO",
        }
    })
    if err then
        log.error("Failed to send data: ", err)
        httpc:close()
        return nil, err
    end
    -- 读取响应体
    local res_body, read_err = res:read_body()
    if read_err then
        log.error("Failed to read response body: ", read_err)
        httpc:close()
        return nil, read_err
    end
    -- 使用 keepalive 以便重用连接
    ok, err = httpc:set_keepalive(60000, 10)
    if not ok then
        log.error("Failed to set keepalive: ", err)
        httpc:close()
        return nil, err
    end

    return {
        status = res.status,
        body = res_body
    }, nil
end

--检查配置文件
function _M.check_schema(conf, schema_type)
    if schema_type == core.schema.TYPE_METADATA then
        return core.schema.check(metadata_schema, conf)
    end
    return core.schema.check(schema, conf)
end

local function verify_jwt(token)
    ngx.thread.spawn()
    local jwt_obj = jwt:verify(auth_secret, token)
    if not jwt_obj["verified"] then
        return nil
    end
    return jwt_obj.payload
end

-- response
-- 如果返回的是一个table就按照table的格式输出
-- 如果返回的是一个string就按照msg = msg的格式输出
local function response(code, msg)
    if type(msg) == "string" then
        msg = { msg = msg, code = code }
    end
    -- 认证需要这种格式
    if code == ngx.HTTP_UNAUTHORIZED then
        msg = { msg = "token is invalid", code = "StatusUnauthorized", status = ngx.HTTP_UNAUTHORIZED }
    end
    return code, msg
end

--处理请求
function _M.rewrite(conf, ctx)
    --解析jwt
    local auth_header = core.request.header(ctx, auth_header_key)
    -- 没有认证信息就直接过
    -- 这里算是漏洞，应该返回401,但是为了兼容上一个版本(上传文件), 所以只能先这样
    if not auth_header then
        return
    end
    local auth_data = core.lrucache.plugin_ctx(lrucache, ctx, nil, verify_jwt, auth_header)
    if not auth_data then
        return response(ngx.HTTP_UNAUTHORIZED)
    end
    local payload, err
    payload, err = json.encode(auth_data)
    if err then
        log.error("json encode error: ", err)
        return response(ngx.HTTP_INTERNAL_SERVER_ERROR, err)
    end
    ctx.jwt = payload
    --添加请求头
    core.request.add_header(user_info_key1, payload)
    core.request.add_header(user_info_key2, payload)
    local method = core.request.get_method()
    local post_body2 = core.request.get_body(1024, ctx)
    if not post_body2 then
        post_body2 = ""
    end
    ctx.post_body = post_body2
    local uri = core.request.get_uri(ctx)
    local user_id = auth_data.user_id
    local httpc_res
    httpc_res, err = send_auth(auth_header, user_id, method, uri)
    if err then
        return response(ngx.HTTP_INTERNAL_SERVER_ERROR, err)
    end
    if httpc_res.status ~= ngx.HTTP_OK then
        return response(httpc_res.status, httpc_res.body)
    end
    return
end

function _M.header_filter(conf, ctx)
    core.response.add_header("Content-Type", "application/json")
    core.response.add_header("X-JiuZhou-Proxy", version)
    core.response.add_header("Developer", "ckallcloud@foxmail.com")
end

-- 记录日志
function _M.log(conf, ctx)
    local scheme = core.request.get_scheme(ctx)
    local method = core.request.get_method()
    local host = core.request.get_host(ctx)
    local uri = core.request.get_uri(ctx)
    local get_args = core.request.get_args(ctx)
    local url = string.format("%s://$s%s%s", scheme, host, uri, get_args)
    local jwt_auth = ctx.jwt
    local route_id = ctx.route_id
    if not jwt_auth then
        jwt_auth = "no auth jwt"
    end
    log.error(string.format(
        'jiuzhou plugins rbac log method: "%s" Host: "%s" Uri: "%s" post_body2: "%s" jwt_obj: "%s" route_id: %d',
        method, host, url, ctx.post_body, jwt_auth, route_id
    ))
    return
end

return _M
