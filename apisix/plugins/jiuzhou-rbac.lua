---
--- Generated by Luanalysis
--- Created by kuncheng.
--- DateTime: 2024/1/24 11:19 AM
---
local core = require("apisix.core")
local jwt = require("resty.jwt")
local http = require("resty.http")
local lrucache = core.lrucache.new({
    type = "plugin",
    count = 10000,
    ttl = 60 * 60,
})
local json = core.json
local auth_header_key = "X-JiuZhou-Authorization"
local auth_secret = "^chen|tian|zhen$"
local user_info_key1 = "X-JiuZhou-Auth-Info"
local user_info_key2 = "user"
local plugin_name = "jiuzhou-rbac"
local log = core.log
local version = "2.0.1"
local schema = {}
local metadata_schema = {}
local ngx = ngx
local _M = {
    version = version,
    name = plugin_name,
    schema = schema,
    priority = 91,
    metadata_schema = metadata_schema,
}


local function send_auth(token, user_id, method, uri)
    local httpc = http.new()
    httpc:set_timeout(5 * 1000) -- 设置连接、发送、读取的总超时时间

    -- 连接到指定主机
    local ok, err = httpc:connect({
        scheme = "http",
        host = "open.duanju.com",
        port = 80,
    })
    if not ok then
        log.error("Failed to connect to host: ", err)
        return nil, err
    end

    -- 设置发送和读取超时
    httpc:set_timeouts(5000, 5000, 5000) -- connect_timeout, send_timeout, read_timeout

    -- 构造请求体
    local body = json.encode({
        user_id = user_id,
        method = method,
        path = uri,
    })

    log.info("Sending request with body: ", body)

    -- 发起 HTTP 请求
    local res
    res, err = httpc:request({
        method = "POST",
        path = "/v1/user/route/app",
        body = body,
        headers = {
            ["Content-Type"] = "application/json",
            ["X-JiuZhou-Authorization"] = token,
            ["X-JiuZhou-Service"] = "AuthSSO",
        }
    })
    if err then
        log.error("Failed to send data: ", err)
        httpc:close()
        return nil, err
    end
    -- 读取响应体
    local res_body, read_err = res:read_body()
    if read_err then
        log.error("Failed to read response body: ", read_err)
        httpc:close()
        return nil, read_err
    end
    -- 使用 keepalive 以便重用连接
    local ok, keepalive_err = httpc:set_keepalive(60000, 10)
    if not ok then
        log.error("Failed to set keepalive: ", keepalive_err)
        httpc:close()
        return nil, keepalive_err
    end

    return {
        status = res.status,
        body = res_body
    }, nil
end

--检查配置文件
function _M.check_schema(conf, schema_type)
    if schema_type == core.schema.TYPE_METADATA then
        return core.schema.check(metadata_schema, conf)
    end
    return core.schema.check(schema, conf)
end

local function verify_jwt(token)
    local jwt_obj = jwt:verify(auth_secret, token)
    if not jwt_obj["verified"] then
        return nil
    end
    return jwt_obj.payload
end
--处理请求
function _M.rewrite(conf, ctx)
    --解析jwt
    local auth_header = core.request.header(ctx, auth_header_key)
    -- 没有认证信息就直接跳过
    if not auth_header then
        return
    end
    local auth_data = core.lrucache.plugin_ctx(lrucache, ctx, auth_header, verify_jwt, auth_header)
    local scheme = core.request.get_scheme(ctx)
    local method = core.request.get_method()
    local host = core.request.get_host(ctx)
    local post_body2 = core.request.get_body(1024, ctx)
    local uri = ctx.var.uri
    local get_args = ""
    if ctx.var.args then
        get_args = "?" .. ctx.var.args
    end
    local url = scheme .. "://" .. host .. uri .. get_args
    if not auth_data then
        return 401,
            {
                message = "Missing authorization in request",
                code = "StatusUnauthorized",
                status = 401,
            }
    end
    core.response.add_header(user_info_key1, auth_data)
    core.response.add_header(user_info_key2, auth_data)
    local user_id = auth_data.user_id
    local request_method = core.request.get_method(ctx)
    local httpc_res, err = send_auth(auth_header, user_id, request_method, uri)
    if err then
        return 500, err
    end
    if httpc_res.status ~= 200 then
        return httpc_res.status, httpc_res.body
    end
    local payload
    payload, err = json.encode(auth_data)
    if err then
        log.error("json encode error: ", err)
    end
    if not post_body2 then
        post_body2 = ""
    end
    log.error(string.format(
        'jiuzhou plugins rbac log method: "%s" Host: "%s" Uri: "%s" post_body2: "%s" jwt_obj: "%s"',
        method, host, url, post_body2, payload
    ))
    return
end

local function my_timer_handler(premature, arg)
    if not premature then
        -- 在这里编写定时任务的具体逻辑
        log.error(ngx.INFO, "定时任务执行了，参数为: ", arg)
    end
end

function _M.header_filter(conf, ctx)
    core.response.add_header("Content-Type", "application/json")
    core.response.add_header("X-JiuZhou-Proxy", version)
    core.response.add_header("Developer", "ckallcloud@foxmail.com")
end

-- 记录日志
--function _M.log(conf, ctx)
--    log.error(ngx.INFO, "log: ", conf, ctx)
--    return
--end

return _M
